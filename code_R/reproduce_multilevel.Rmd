---
title: "Untitled"
output: html_document
---

all code copied from streamlit to check reproducibility. 
this needs to be checked again.

```{r}
### R: packages & reproducibility ###
pacman::p_load(
    tidyverse, 
    brms,
    modelr,
    tidybayes,
    bayesplot)
RANDOM_SEED = 42
```

```{r}
### R: preprocessing ###
train <- read_csv("../data/train.csv") %>%
    mutate(idx = as_factor(idx))
```

```{r}
### R: specify model & compile ###
# formula 
f_multilevel <- bf(y ~ 1 + t + (1+t|idx)) # random eff. structure 

# set priors --> can use get_prior() if in doubt. 
prior_multilevel <- c(
    prior(normal(0, 0.5), class = b),
    prior(normal(1.5, 0.5), class = Intercept),
    prior(normal(0, 0.5), class = sd), # new
    prior(normal(0, 0.5), class = sigma),
    prior(lkj(1), class = cor) # new
)

# compile model & sample prior
m_multilevel <- brm(
    formula = f_multilevel,
    family = gaussian,
    data = train,
    prior = prior_multilevel,
    sample_prior = "only",
    backend = "cmdstanr")

```

```{r}
### R: Prior predictive checks ###
pp_check(m_multilevel, 
        nsamples = 100) +
    labs(title = "R/brms: prior predictive check") 
```

```{r}
### R: sample posterior ###
m_multilevel <- brm(
    formula = f_multilevel,
    family = gaussian,
    data = train,
    prior = prior_multilevel,
    sample_prior = TRUE, # only difference. 
    backend = "cmdstanr",
    chains = 2,
    cores = 4,
    iter = 4000, 
    warmup = 2000,
    threads = threading(2), # not sure this can be done in pyMC3
    control = list(adapt_delta = .99,
                    max_treedepth = 20),
    seed = RANDOM_SEED)
```

```{r}
### R: plot trace ###
plot(m_multilevel,
    N = 10) # N param per plot. 
```

```{r}
### R: get summary (not displayed) ###
summary(m_multilevel)
```

```{r}
### R: Posterior predictive checks ###
pp_check(m_multilevel, 
        nsamples = 100) + 
labs(title = "R/brms: posterior predictive check") 
```

```{r}

### R: HDI prediction intervals ###
train %>%
    data_grid(t = seq_range(t, n = 100), idx) %>%
    add_predicted_draws(m_multilevel) %>%
    ggplot(aes(x = t, y = y)) + 
    stat_lineribbon(aes(y = .prediction), 
                    .width = c(.95, .8), # HDI intervals
                    color = "#08519C",
                    point_interval = median_hdi) + 
    geom_jitter(data = train, 
                color = "navyblue", 
                shape = 1,
                alpha = 0.5, 
                size = 2, 
                width = 0.1) + 
    scale_fill_brewer() + 
    ggtitle("R/brms: Prediction intervals (full)")
```

```{r}
### R: HDI prediction intervals ###
train %>%
    data_grid(t = seq_range(t, n = 100), idx) %>%
    add_fitted_draws(m_multilevel,
                     re_formula = NA) %>%
    ggplot(aes(x = t, y = y)) + 
    stat_lineribbon(aes(y = .value), 
                    .width = c(.95, .8), # HDI intervals
                    color = "#08519C",
                    point_interval = median_hdi) + 
    geom_jitter(data = train, 
                color = "navyblue", 
                shape = 1,
                alpha = 0.5, 
                size = 2, 
                width = 0.1) + 
    scale_fill_brewer() + 
    ggtitle("R/brms: Prediction intervals (fixed)")
```

```{r}
### R: HDI for parameters ###
mcmc_areas(
m_multilevel,
pars = c("b_Intercept",
        "b_t",
        "sigma"),
prob = 0.8, # 80% intervals
prob_outer = 0.99, # 99%
point_est = "mean") + # or median?
ggtitle("R/brms: HDI intervals for parameters")
```

