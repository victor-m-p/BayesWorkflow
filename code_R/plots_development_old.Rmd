---
title: "plots_development_scrap"
output: html_document
---

trying to get HPDI. 

```{r}

test <- posterior_samples(m_multilevel_posterior) %>%
  median_qi()

m_multilevel_posterior %>%
  gather_draws(b_intercept) %>%
  glimpse()

# chapter 5 (recoded). 
train %>%
  data_grid(t = seq_range(t, n = 50), idx) %>%
  add_predicted_draws(m_student_posterior) %>%
  ggplot(aes(x = t, y = .prediction)) + 
  stat_halfeye(point_interval = mode_hdi, .width = .95)
  #stat_lineribbon(aes(y = .prediction), .width = c(.95, .8), color = "#08519C") +
  #geom_jitter(data = train, color = "#2874a6", alpha = 0.5, size = 2, width = 0.1) + 
  #scale_fill_brewer()

# second try
mcmc_plot(m_student_posterior,
          pars = c("b_Intercept",
                   "b_t",
                   "sigma"),
          fixed = TRUE)

  #theme(axis.text.y = element_text(hjust = 0))
nd <- train %>%
  data_grid(t = seq_range(t, n = 50), idx)

test <- fitted(m_student_posterior, 
       newdata = nd,
       summary = F) %>%
  as_tibble() %>%
  gather()

fitted(m_student_posterior)

nd <- tibble(clade_nwm = c(1, 0, 0, 0),
             clade_owm = c(0, 1, 0, 0),
             clade_s   = c(0, 0, 1, 0),
             primate   = c("New World Monkey", "Old World Monkey", "Strepsirrhine", "Ape"))

fitted(b5.16,
       newdata = nd,
       summary = F) %>% 
  as_tibble() %>% 
  gather() %>% 
  mutate(primate = rep(c("New World Monkey", "Old World Monkey", "Strepsirrhine", "Ape"), 
                       each = n() / 4)) %>% 
  
  ggplot(aes(x = value, y = reorder(primate, value))) +
  geom_halfeyeh(fill = "firebrick4", 
                point_interval = median_qi, .width = .95) +
  labs(x = "kcal.per.g",
       y = NULL) +
  theme_bw() +
  theme(panel.grid   = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y  = element_text(hjust = 0))
```

FOR EACH ACTOR (perhaps don't even show). 

```{r}
# if we want it for each actor #
train %>%
  data_grid(t = seq_range(t, n = 50), idx) %>%   
  add_predicted_draws(m_multilevel_posterior) %>%
  ggplot(aes(x = t, y = y)) +
  stat_lineribbon(aes(y = .prediction), .width = c(.95, .8), color = "#08519C") +
  geom_point(data = train) +
  scale_fill_brewer() +
  facet_wrap(~ idx)    
```
## predictions and fits: pooled model. 

trying it with raw data. 

```{r}

# pooled model
samples_pooled <- posterior_samples(m_pooled_posterior) 

```

with summary statistics (not draws). 
here we can get both in one plot. 

```{r}

# https://bookdown.org/ajkurz/Statistical_Rethinking_recoded/linear-models.html#why-normal-distributions-are-normal
# stolen directly.. 

# x values to predict / fit on. 
time_seq <- tibble(t = seq(from = 0, to = 9, by = 0.1))

# using fitted() and predict() 

# fitted
fitted_pooled <- fitted(m_pooled_posterior,
                        newdata = time_seq) %>%
  as_tibble() %>%
  bind_cols(time_seq)

# plot fitted individually
train %>%
  ggplot(aes(x = t, y = y)) +
  geom_smooth(data = fitted_pooled,
              aes(y = Estimate, ymin = Q2.5, ymax = Q97.5),
              stat = "identity",
              fill = "grey70", color = "black", alpha = 1, size = 1/2) +
  geom_point(color = "navyblue", shape = 1, size = 1.5, alpha = 2/3) +
  coord_cartesian(xlim = range(train$t)) +
  theme(text = element_text(family = "Times"),
        panel.grid = element_blank())

# predict 
predictions_pooled <-
  predict(m_pooled_posterior,
          newdata = time_seq) %>%
  as_tibble() %>%
  bind_cols(time_seq)

# plot predict individually (prediction intervals). 
train %>%
  ggplot(aes(x = t, y = y)) +
  geom_smooth(data = predictions_pooled,
              aes(y = Estimate, ymin = Q2.5, ymax = Q97.5),
              stat = "identity",
              fill = "grey70", color = "black", alpha = 1, size = 1/2) +
  geom_point(color = "navyblue", shape = 1, size = 1.5, alpha = 2/3) +
  coord_cartesian(xlim = range(train$t)) +
  theme(text = element_text(family = "Times"),
        panel.grid = element_blank())

# plot them together 
train %>%
  ggplot(aes(x = t)) + 
  geom_ribbon(data = predictions_pooled,
              aes(ymin = Q2.5, ymax = Q97.5),
              fill = "grey83") +
  geom_smooth(data = fitted_pooled,
              aes(y = Estimate, ymin = Q2.5, ymax = Q97.5),
              stat = "identity",
              fill = "grey70", color = "black", alpha = 1, size = 1/2) +
  geom_point(aes(y = y),
             color = "navyblue", shape = 1, size = 1.5, alpha = 2/3) +
  coord_cartesian(xlim = range(train$t)) +
  theme(text = element_text(family = "Times"),
        panel.grid = element_blank())
  
```

doing it with build-in functionality.
quite nice for the "fitted" case. 

```{r}

# https://bookdown.org/ajkurz/Statistical_Rethinking_recoded/interactions.html

## fitted
plot(conditional_effects(m_pooled_posterior, 
                         spaghetti = T, 
                         nsamples = 100,
                         mean = F,
                         method = "fitted"),
     points = T)

## predict
plot(conditional_effects(m_pooled_posterior, 
                         spaghetti = T, 
                         nsamples = 100,
                         mean = F,
                         method = "predict"),
     points = T)

```

# predictions and fits: multilevel model

https://bookdown.org/ajkurz/Statistical_Rethinking_recoded/multilevel-models.html (CH12)

```{r}

# data wrangling. 
idx_len <- length(unique(train$idx))
t_max <- max(train$t)
t_min <- min(train$t)
seq_length <- length(seq(from = t_min, to = t_max, by = 0.1))

# x values to predict / fit on. 
new_data <- tibble(t = rep(seq(from = t_min, to = t_max, by = 0.1), each = idx_len),
                       idx = rep(seq(from = 0, to = 14, by = 1), times = seq_length))

# predict 
predict_multilevel <- predict(m_multilevel_posterior,
                              allow_new_levels = T, # should not be necessary here actually. 
                              re_formula = ~ (1+t|idx),
                              newdata = new_data,
                              probs = c(.025, .975)) %>%
  as_tibble() %>%
  bind_cols(new_data)

predict_multilevel %>% 
  glimpse()

predict_multilevel %>%
  ggplot(aes(x = log(population), y = Estimate)) +
  geom_ribbon(aes(ymin = Q2.5,  ymax = Q97.5), fill = "orange2", alpha = 1/3) +
  geom_line(color = "orange4") +
  geom_text(data = train, aes(y = y, label = idx), 
            size = 2.33, color = "blue") +
  ggtitle("predictions with prediction intervals") +
  coord_cartesian(ylim = range(train$t)) +
  theme_fivethirtyeight() +
  theme(plot.title = element_text(size = 12, hjust = .5))

# fitted
fitted_pooled <- fitted(m_multilevel_posterior,
                        newdata = time_seq) %>%
  as_tibble() %>%
  bind_cols(time_seq)

```

For new IDX.

```{r}

# data wrangling. 
idx_len <- length(unique(train$idx))
t_max <- max(train$t)
t_min <- min(train$t)
seq_length <- length(seq(from = t_min, to = t_max, by = 0.1))

# x values to predict / fit on. 
new_data <- tibble(t = rep(seq(from = t_min, to = t_max, by = 0.1)),
                       idx = rep(15, times = seq_length))

# predict 
predict_multilevel <- predict(m_multilevel_posterior,
                              allow_new_levels = T, # should not be necessary here actually. 
                              re_formula = ~ (1+t|idx),
                              newdata = new_data,
                              probs = c(.025, .975)) %>%
  as_tibble() %>%
  bind_cols(new_data)

predict_multilevel %>% 
  glimpse()

predict_multilevel %>%
  ggplot(aes(x = t, y = Estimate)) +
  geom_ribbon(aes(ymin = Q2.5,  ymax = Q97.5), fill = "orange2", alpha = 1/3) +
  geom_line(color = "orange4") +
  geom_point(data = train, 
             aes(y = y), color = "#DCA258") +
  ggtitle("predictions with prediction intervals") +
  theme(plot.title = element_text(size = 12, hjust = .5))


# fitted
# x values to predict / fit on. 
new_data <- tibble(t = rep(seq(from = t_min, to = t_max, by = 0.1), each = idx_len),
                       idx = rep(seq(from = 0, to = 14, by = 1), times = seq_length))

fitted_multilevel <- fitted(m_multilevel_posterior,
                            newdata = new_data,
                            allow_new_levels = TRUE) %>%
  as_tibble() %>%
  bind_cols(new_data)

fitted_multilevel %>%
  ggplot(aes(x = t, y = Estimate)) +
  geom_ribbon(aes(ymin = Q2.5,  ymax = Q97.5), fill = "orange2", alpha = 1/3) +
  geom_line(color = "orange4") +
  geom_point(data = train, 
             aes(y = y), color = "#DCA258") +
  ggtitle("predictions with prediction intervals") +
  theme(plot.title = element_text(size = 12, hjust = .5))

```

https://biol609.github.io/lectures/23c_brms_prediction.html
http://mjskay.github.io/tidybayes/

```{r}

# required for this. 
pacman::p_load(tidybayes)

# fixed effects only (and fitted). 
fixed_fit_multilevel <- tibble(t = seq(min(train$t), 
                          max(train$t), 
                          length.out=100)) %>%
  add_fitted_draws(m_multilevel_posterior,
                   re_formula = NA,
                   scale = "response", 
                   n = 1e3)

# get the mean
fixed_fit_multilevel_mean <- fitted_multilevel %>% 
  group_by(t) %>%
  summarize(.value = mean(.value))

# plot it (just needs better color schema)
ggplot(fixed_fit_multilevel, aes(x = t, y = .value)) +
  geom_line(aes(group = .draw), alpha = 0.1) +
  geom_line(aes(group = .draw), data = fixed_fit_multilevel_mean, color = "red", lwd = 2, group = 1) +
  geom_point(data = train, aes(x = t, y = y))

# random effects (and fitted)
random_fit_multilevel <- crossing(t = seq(min(train$t), 
                                  max(train$t), 
                                  length.out=100),
                                  idx = unique(train$idx)) %>%
  add_fitted_draws(m_multilevel_posterior,
                   scale = "response",
                   n = 1e3)

# get the mean
random_fit_multilevel_mean <- random_fit_multilevel %>%
  group_by(t, idx) %>%
  summarize(.value = mean(.value))

# fits 
ggplot(random_fit_multilevel_mean,
       aes(x = t, y = .value)) +
  geom_line(aes(group = idx), alpha = 0.8) +
  geom_line(data = fixed_fit_multilevel_mean, color = "red", lwd = 2)

# simulations (fits) for all
ggplot(random_fit_multilevel,
       aes(x = t, y = .value)) +
  geom_line(aes(group = .draw), alpha = 0.1) +
  geom_line(data = random_fit_multilevel_mean, alpha = 0.8, 
            color = "red", lwd = 1) +
  facet_wrap(~idx)

# hmmm
ggplot(random_fit_multilevel,
       aes(x = t, y = .value)) +
  stat_interval() 

# add predicted draws: 
random_fit_multilevel <- crossing(t = seq(min(train$t), 
                                  max(train$t), 
                                  length.out=100),
                                  idx = unique(train$idx)) %>%
  add_predicted_draws(m_multilevel_posterior) 

ggplot(random_fit_multilevel,
       aes(x = t, y = .prediction)) + 
  stat_interval()

# overall predictive posterior?


```
