\documentclass[12pt]{article}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks = true,
    citecolor = {black}}
\usepackage{wrapfig}
\setlength{\parindent}{0pt}
\usepackage{tgtermes}
\usepackage{setspace}
\usepackage{gensymb}
\doublespacing
\usepackage{graphicx}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage[backend=biber,style=apa,autocite=inline]{biblatex}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Paper 1}
\rhead{Victor M. Poulsen, Studie Nr.: 201707639}

\DeclareLanguageMapping{english}{english-apa}
\addbibresource{report.bib}

\title{Human Computer Interaction}
\author{Victor Møller Poulsen, Studie Nr.: 201707639}

\begin{document}
\maketitle
\leavevmode

\section{Abstract}
This paper presents a prototype Streamlit app which teaches a Gelman
\autocite{gelman2020bayesian} inspired Bayesian workflow
in R with the package brms \autocite{Burkner2017} and in Python with the
package pyMC3 \autocite{Salvatier2016}. The app is built with theories from user
experience (UX) in mind and relies on a well-documented and reproducible codebase. The app is
aimed at users who are already familiar with Bayesian analysis in either R
(brms) or Python (pyMC3) and should be used as an introduction to the
implementation that the user is unfamiliar with. The app has several
interactive elements, including optional sections that the user can expand to
dive deeper into parts of the material, quizzes with feedback and live
rendering of plots and figures based on user selection. \\
Link to app: \href{https://share.streamlit.io/victor-m-p/bayesworkflow/main/BayesWorkflow.py}{Stremlit app}\\
Link to Github: \href{https://github.com/victor-m-p/BayesWorkflow}{Github page}

\section{Introduction}

The main idea with this app is to teach users who know how to conduct a Bayesian analysis in one coding
language how to conduct a similar analysis in the other coding language. This is something
that I had to figure out when we transitioned from using R and brms for Bayesian analyses
on the Cognitive Science Bachelor's degree to using Python and pyMC3 on the Cognitive Science
Master's degree. There are lots of great resources and examples both online and in books for both
brms and pyMC3 independently, but I have so far not found any resources that directly map between
the two. That is the niche that this Streamlit app is intended to occupy.

\vspace{5mm}

Besides differing in content from books and online resources, this app is also intended
to be interactive. This is important because it facilitates user engagement and
agency \autocite{janlert2017meaning}.
It also useful because it means that we can let the user select what they want to see on
their screen and which parts they would like to engage more with. It thus saves a lot of
clutter from the app, because we do not have to display everything at once.
This means that the app can have extensive functionality and retain high
usability.
This is where Streamlit becomes relevant. Streamlit is a Python package which allow users
to launch interactive web applications to showcase analyses. It thus fulfills the same function
that Shiny fulfills in the coding language R. Streamlit is developing rapidly however,
and already appears to support more diverse options than Shiny. I chose to use
streamlit for this reason.

\section{Target Group}
Obtaining knowledge and understanding of the target group for a product is among the
most important steps to creating a useful product
\autocite[13]{mills1992macintosh}.
The target group for this app is people who are familiar with Bayesian statistics and know
how to conduct a Bayesian analysis in either R (brms) or Python (pyMC3). The idea is to
conduct (almost) identical analyses in the two languages, such that users can
transfer what they already know in one language to the other language.
Explanations are targeted more towards users who want to transition from R (brms)
to Python (pyMC3) than the other way. This is because I have kept Cognitive Science students
in mind as the primary audience. Most Cognitive Science students have been
taught Bayesian statistics in the R programming language, as implemented in the
brms package. I am in the privileged position of knowing my audience well. I
have both (1) been taught Bayesian statistics in R on the Cognitive Science
Bachelor's degree, and (2) been instructor on the Bachelor's course in which
the students learn Bayesian statistics in R.
While the app is mainly designed with Cognitive Science students in mind,
the app should also be useful for users outside of Cognitive Science.
Python and R are the two largest Data Science programming
languages, and as such it is common for Data Scientists to code in both
languages.

\section{Intended Usage}
The first use case (\emph{UC1}) that I think is reasonable is to use the app as a one-time
thorough introduction, where users should ideally run their own code in Python and/or R
while following the analysis on the app. This should be relatively easy since I provide reproducible code
for all parts of the analysis, which can be easily copied to clipboard from the expandable
code-chunks. Users do not need to manually select the code they want to copy, but can simply click
the text selection icon in the upper-right corner of the code-cunks.
For \emph{UC1} the user will have to interact with the page,
expand code-selections and explanations and tweak the plots to get a feel for what is going on.
As such, this is the use case where the user will utilize the full
functionality of the app.
The user might also learn something new, either conceptually or related to a
healthy Bayesian workflow.
This however is secondary to the main goal of building a bridge between the code implementations.

\vspace{5mm}

The second use case (\emph{UC2}) that I think makes sense is to use the app repeatedly as a reference
while conducting an analysis in either pyMC3 or brms. The user can quickly glance through the
app to be reminded of how a good Bayesian workflow can look for either implementation.
I have also included a section with references that I have found helpful for both pyMC3 and brms,
and as such the user can also use the app as a gateway to more advanced analyses.
For this use case the user might not want to expand the optional sections,
but simply glance through the plots and headers to quickly find what they are looking for.
For this use case, only a small part of the functionality in the app is used.

\section{Design Philosophy}
The design philosophy for the app is naturally related to the content that it attempts to convey and
introduce to the user. It is also designed to facilitate both \emph{UC1} and
\emph{UC2}. The design philosophy burrows from the Pragmatic/Hedonic model of
User Experience (UX) which is described in \textcite{hassenzahl2010experience} as well as the design
principles outlined in \textcite{mills1992macintosh}.

\vspace{5mm}

Firstly, the app is designed with a philosophy of \emph{avoiding clutter} in mind.
The importance of this is emphasized througout \textcite{mills1992macintosh}.
I have hidden everything that I think is not necessary for navigating the app
in in expandable sections. I wanted to avoid cluttering the
app with text specifically since this can feel intimidating and could scare users away.
If users want to use the app in line with \emph{UC1} they will have to interact with the optional
elements and decide to see the code-chunks and the optional explanatory sections.
If these were shown by default, I think that \emph{UC2} would not be facilitated well by the app.

\vspace{5mm}

Secondly, the app is designed with \emph{consistency} in mind.
The importance of consistency is discussed in
\textcite[7]{mills1992macintosh}
where they highlight that consistency allows users to transfer knowledge from one
application to another. In our case, since we only have one app, what will be important is
that users can transfer what they have learned in one section to other sections.
In other words, I am aiming for the app to be consistent within itself
\autocite[8]{mills1992macintosh}.
The users will quickly learn that there are three types of expandable boxes in the app:
“Code-Monkey”, “Language-Learner” and “Concept-Guru”. Each of these expandable sections
allow the user to access different types of additional info. When clicked, the “Code-Monkey”
sections will pop out and show reproducible code, “Language-Learner” sections go into more detail
about how R (brms) differ from Python (pyMC3) while “Concept-Guru” sections discuss Bayesian analysis
more generally. The order of presentation is also consitent throughout.
Each subsection starts with a header and is then followed by a brief text.
Below this are plots or outputs from Python and R, and only after this will the user find
the optional sections. These are also presented in consistent order, such that “Code-Monkey” comes first,
“Language-Learner” second and “Concept-Guru” comes last. Additionally, each expandable section
has a unique icon associated with it. This has been implemented to make it easier for the
user to navigate the page. \textcite[223-255]{mills1992macintosh} focus
heavily on the importance of icons. One highlighted advantage of icons is that users typically
will recognize images faster than they will read text
\autocite[244]{mills1992macintosh}.

\vspace{5mm}

Third, the app should be \emph{pretty} and \emph{simple}. These are general
and obvious design principles which are discussed in
\textcite{tractinsky2000beautiful} as well as
\textcite[25-26]{hassenzahl2010experience}.
I have created a custom color-theme for the app, which I think makes the app more interesting
than with the standard white theme. I have also tried to make the formatting both inside
streamlit, and for the R and Python plots pretty. Considerations around making
the app engaging
and pretty, is another reason why I show plots by default and hide most text and code by default.
I hope that users will find that the app and the content on it is pretty,
something that is understood to be an important driver
in creating an enjoyable experience \autocite[65]{hassenzahl2010experience}.

\section{Interaction}
There are three basic types of interaction implemented in the app
at this point. They provide a relatively high level of
interactability, with adaptable outputs that are contingent on
user selection \autocite{janlert2017meaning}.

\vspace{5mm}

Firstly, the user can choose which model and prior to see analysis for.
Plots and figures from R and Python are shown by default and cannot be toggled off by the user.
However, the user can influence what is shown in plots. In most cases the user can choose
among different prior options that have been used to fit the models in the app.
In some cases, the user can choose to plot the outputs of analysis between different models,
e.g. with different random effects structure and likelihood functions.
When the user makes a selection the plots and figures will change,
and the code in the “Code-Monkey” sections will also change in the cases where the analyses differ.
As such, the display is contingent on the actions of the user,
and there is an element of adaptability imbedded in the
app \autocite{janlert2017meaning}.


\vspace{5mm}

Secondly, the user can choose to expand the optional sections:
“Code-Monkey”, “Language-Learner” and “Concept-Guru”.
As I have already said, the “Code-Monkey” section will render code which matches the selection.
Most often, the content in “Language-Learner” and “Concept-Guru” will not differ
based on the selection of the user, because these sections contain more general considerations.

\vspace{5mm}

The degree to which a
product engages the user in interaction has been called \emph{interactiveness}
\autocite{janlert2017meaning}. This is implemented as quizzes that the app
presents to users and the feedback that the app provides based on user answers.
These quizzes are not shown on the page by default but hide inside the expandable boxes.
Again, this was done to ensure that the app will not be too cluttered and can be glanced
through quickly (for \emph{UC2}).

\vspace{5mm}

Streamlit is often used for Data Science applications which run extremely
fast machine learning analyses or frequentist statistics. The apps are typically
interactive in the sense that when the user makes a choice some corresponding code is run,
which generates an output. This means that the possibility space is almost
infinite, and as such these apps are high on interactiveness
\autocite{janlert2017meaning}. This is not the case in the prototype app that
I am presenting. In my case, I am not running any analysis code live because full
Bayesian sampling is prohibitively slow. Thus, I have made an extensive code base
from which I generate plots and outputs from several analyses
(e.g. for different priors and different models) that the user then sees based on
selection. As such, the functionality, or interactability is limited to what I
have already pre-run. This is a classic trade-off between functionality on one
hand (flexible options) and usability on the other (no delay in runtime).
However \textcite{janlert2017meaning} point out that higher interactability
does not necessarily mean that a product has higher agency. Even though the
app only offers limited interactability I hope that it does give users a
sense of agency. If users want to tweak the analysis in ways that I have not
facilitated, they \emph{should} run their own code anyways. After all, the whole
purpose is to teach users how to implement Bayesian analysis,
and the best way for users to learn that is to code themselves.

\section{Code Base}
Although I have focused extensively on the user experience (UX) on the app,
the most demanding work has been to develop good analyses and managing an extensive
code base which must be reproducible. I will not go too deep into that here,
as you can check the
\href{https://github.com/victor-m-p/BayesWorkflow}{Github}.
There are bash-scripts for both R and Python
which execute all the necessary scripts to run the whole pipeline
and reproduce all analysis on the streamlit app. This means that if users have
the necessary packages in their environment, they can run all R and Python analysis
with two lines of code from their terminal. This is of course unnecessary for most users,
who should just see the app, but it is an option for users who want to dive deeper
into the analysis and the convenience functions that I have created. It is
important not exclusively to focus on the "average" user
\autocite[14]{mills1992macintosh}.
Besides this, a well-structured code base has been absolutely necessary for me to
be able to manage the project and ensure that all formatting is consistent.

\section{Improvements \& Testing}
Something I really would have liked to implement in the app is a consistent
color-code for the expandable sections that I have. This would make sense
because I use the same three types of boxes (“Code-Monkey”, “Language-Learner” and “Concept-Guru”)
throughout the app. A color scheme, where each type of section has its own color-code
should make the page more intuitive to navigate. Unfortunately, this functionality
is not natively supported in Streamlit. Streamlit can be configured with CSS code,
so in principle it should be possible to implement. Unfortunately, I am unfamiliar
with CSS so there is currently no color-coding for the expandable sections.
As I have mentioned previously, each section has an associated icon,
which aims to achieve the same. I do think that colored sections would make
it more visceral and would improve the user experience.

\vspace{5mm}

With regards to feedback and interactivity there is one thing that would be ideal
to implement for the use cases that the app attempts to facilitate. At present,
the user is only quizzed with multiple choice questions. This is because it is easy
to handle, since I can specify the feedback for a limited number of options.
This is what is currently supported, and can be characterized as a
"responding" interaction type \autocite[81]{rogers2011interaction}.
Because the app attempts to teach the user code-practices it would make sense to
have a system which corresponds to what is used on platforms such as DataCamp.
On DataCamp users type in code, which is then evaluated, and the user received feedback
based on what the code evaluates to. This would correspond to a "conversing"
interaction type \autocite[81]{rogers2011interaction},
and would be more sophisticated than what is currently in
place. The tricky part is that the code has to be
compiled,
and not just treated as a string of text. Treating the input as a string
is infeasible, because code which does the same can be expressed in infinitely many ways,
There also has to be a nice interface where the user can type in the code that
they want to execute. I think that both would be tricky to implement, especially the
first part. Another reason to not support this functionality is that I would ideally
like users to code along from their own instance of R and/or Python.

\vspace{5mm}

I intend to share the app in cognitive science forums once I have double checked
that everything is reproducible, and that everything is well documented. Hopefully,
the app will be useful to some of the students, and perhaps some outsiders will even
find their way to the app. Additionally, sharing the app should give me the chance
to receive feedback on whether the app is usable. Both whether the content is good
and whether the format is intuitive. I intend to gather verbal feedback,
although I know that this is not the ideal testing conditions.

\vspace{5mm}

There are at least two ways of gathering feedback that could be more useful
than verbal feedback. Firstly, one could attempt a quantitative evaluation,
e.g. based on A-B testing, eye-tracking data and statistical analysis.
A good example of this approach can be found in \textcite{sutcliffe2016}.
Perhaps more useful approach in our case would be to simply observe users who interact
with the app. \textcite{norman1999} has argued that the best way of finding
out how users engage with products is to observe them engage with products.
I think this is true in this case, where one of my main interests is simply
\emph{how} users engage with the app (e.g. \emph{UC1}, \emph{UC2} or something
else).

\section{Conclusion}
This paper has introduced a streamlit app which teaches a Bayesian workflow in R (brms)
and Python (pyMC3). The app is designed for users who are already familiar with Bayesian
analysis in either R (brms) or Python (pyMC3). The app focuses on building a bridge
between the implementations in the different languages and packages.
The app supports limited interaction through selection boxes, and expandable
sections for the user who wants to dive deeper. The app also attempts to engage
the user with quizzes and provides feedback based on answers. The app is designed with
a philosophy of consistency, simplicity and beauty in mind. Users who want to
go further than the app supports can consult a well organized code-base at
\href{https://github.com/victor-m-p/BayesWorkflow}{Github}
\printbibliography
\end{document}


