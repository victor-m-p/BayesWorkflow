data = d,
family = gaussian,
)
# fit a model
f0 <- bf(y ~ time) # no random effects structure.
f1 <- bf(y ~ time + (1|id)) # random intercept.
f2 <- bf(y ~ time + (1+time|id)) # random intercept & slope.
# fit the first model
get_prior(formula = f0,
data = d,
family = gaussian,
)
# set priors
prior_f0 <- c(
prior(normal(0, .3), class = b),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sigma)
)
# try the model with only intercepts
get_prior(formula = ff1,
data = d,
family = gaussian)
# set priors: here we only have sigma
prior_f0 <- c(
prior(normal(0, .3), class = b),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sigma)
)
# fit the first model
get_prior(formula = f0,
data = d,
family = gaussian,
)
# set priors: here we only have sigma - not SD.
prior_f0 <- c(
prior(normal(0, .3), class = b),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sigma)
)
getwd()
setwd("~/BayesWorkflow/code")
# working directory and packages
setwd("~/BayesWorkflow/code")
# packages
pacman::p_load(tidyverse,
brms)
# working directory
setwd("~/BayesWorkflow/code")
# packages
pacman::p_load(tidyverse,
brms)
# get data.
set.seed(44)
n_id = 10
n_time = 10
d <- tibble(
id = rep(1:n_id, each = n_time),
a_real = rep(rnorm(n_id, mean = 1, sd = 0.5), each = n_time),
b_real = rep(rnorm(n_id, mean = 0.3, sd = 0.2), each = n_time),
time = rep(0:(n_time-1), n_id),
eps_real = rnorm(n_id*n_time, mean = 0, sd = 0.5),
y = a_real + b_real * time + eps_real
)
# make sure that data format is okay
d <- d %>%
mutate(id = as_factor(id))
# something like this could work.
d %>%
ggplot(aes(x = time, y = y, color = id)) +
geom_point() +
geom_smooth(method = "lm")
fit_mod <- function(formula,
family,
data,
prior,
sample_prior,
file){
b <- brm(
formula = formula,
family = family,
data = data,
prior = prior,
cores = 4, chains = 2,
sample_prior = sample_prior,
backend = "cmdstanr",
file = file,
file_refit = "on_change",
threads = threading(2),
control = list(adapt_delta = .99,
max_treedepth = 20)
)
return(b)
}
# fit a model
f0 <- bf(y ~ time) # no random effects structure.
f1 <- bf(y ~ time + (1|id)) # random intercept.
f2 <- bf(y ~ time + (1+time|id)) # random intercept & slope.
# fit the first model
get_prior(formula = f0,
data = d,
family = gaussian,
)
# set priors: here we only have sigma - not SD.
prior_f0 <- c(
prior(normal(0, .3), class = b),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sigma)
)
# try the model with only intercepts
get_prior(formula = f1,
data = d,
family = gaussian)
# specify prior
prior_f1 <- c(
prior(normal(0, .3), class = b),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sd),
prior(normal(0, .5), class = sigma)
)
# specify prior
prior_f1 <- c(
prior(normal(0, .3), class = b),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sd),
prior(normal(0, .5), class = sigma)
)
# prediction within groups (how will they continue to develop).
get_prior(formula = f2,
data = d,
family = gaussian)
# set priors
prior_ff2 <- c(
prior(normal(0, .3), class = b),
prior(lkj(2), class = cor),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sd),
prior(normal(0, .5), class = sigma)
)
# set priors
prior_f2 <- c(
prior(normal(0, .3), class = b),
prior(lkj(2), class = cor),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sd),
prior(normal(0, .5), class = sigma)
)
# Chunk 1
# working directory
setwd("~/BayesWorkflow/code")
# packages
pacman::p_load(tidyverse,
brms)
# Chunk 2: setup
# get data.
set.seed(44)
n_id = 10
n_time = 10
d <- tibble(
id = rep(1:n_id, each = n_time),
a_real = rep(rnorm(n_id, mean = 1, sd = 0.5), each = n_time),
b_real = rep(rnorm(n_id, mean = 0.3, sd = 0.2), each = n_time),
time = rep(0:(n_time-1), n_id),
eps_real = rnorm(n_id*n_time, mean = 0, sd = 0.5),
y = a_real + b_real * time + eps_real
)
# make sure that data format is okay
d <- d %>%
mutate(id = as_factor(id))
# something like this could work.
d %>%
ggplot(aes(x = time, y = y, color = id)) +
geom_point() +
geom_smooth(method = "lm")
# Chunk 3
fit_mod <- function(formula,
family,
data,
prior,
sample_prior,
file){
b <- brm(
formula = formula,
family = family,
data = data,
prior = prior,
cores = 4, chains = 2,
sample_prior = sample_prior,
backend = "cmdstanr",
file = file,
file_refit = "on_change",
threads = threading(2),
control = list(adapt_delta = .99,
max_treedepth = 20)
)
return(b)
}
# Chunk 4
# fit a model
f0 <- bf(y ~ time) # no random effects structure.
f1 <- bf(y ~ time + (1|id)) # random intercept.
f2 <- bf(y ~ time + (1+time|id)) # random intercept & slope.
#ff3 <- bf(y ~ time + I(time^2) + (1+time|id)) # time second order
# fit the first model
get_prior(formula = f0,
data = d,
family = gaussian,
)
# set priors: here we only have sigma - not SD.
prior_f0 <- c(
prior(normal(0, .3), class = b),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sigma)
)
# fit the prior
m0_prior <- fit_mod(
formula = f0,
family = gaussian,
data = d,
prior = prior_f0,
sample_prior = "only",
file = "../models/f0_prior"
)
# fit the posterior
m0_post <- fit_mod(
formula = f0,
family = gaussian,
data = d,
prior = prior_f0,
sample_prior = T,
file = "../models/f0_post"
)
# try the model with only intercepts
get_prior(formula = f1,
data = d,
family = gaussian)
# specify prior
prior_f1 <- c(
prior(normal(0, .3), class = b),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sd),
prior(normal(0, .5), class = sigma)
)
# fit prior model
m1_prior <- fit_mod(
formula = f1,
family = gaussian,
data = d,
prior = prior_f1,
sample_prior = "only",
file = "../models/m1_prior"
)
# fit model (go back to prior pred).
m1_post <- fit_mod(
formula = f1,
family = gaussian,
data = d,
prior = prior_f1,
sample_prior = T,
file = "../models/m1_post"
)
# prediction within groups (how will they continue to develop).
get_prior(formula = f2,
data = d,
family = gaussian)
# set priors
prior_f2 <- c(
prior(normal(0, .3), class = b),
prior(lkj(2), class = cor),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sd),
prior(normal(0, .5), class = sigma)
)
# fit prior model
m2_prior <- fit_mod(
formula = f2,
family = gaussian,
data = d,
prior = prior_f2,
sample_prior = "only",
file = "../models/m2_prior")
# fit the posterior
m2_post <- fit_mod(
formula = f2,
family = gaussian,
data = d,
prior = prior_f2,
sample_prior = T,
file = "../models/m2_post"
)
## pp checks
## models
## loo
# working directory
setwd("~/BayesWorkflow/code")
# packages
pacman::p_load(tidyverse,
brms)
# get data.
set.seed(44)
n_id = 10
n_time = 10
d <- tibble(
id = rep(1:n_id, each = n_time),
a_real = rep(rnorm(n_id, mean = 1, sd = 0.5), each = n_time),
b_real = rep(rnorm(n_id, mean = 0.3, sd = 0.2), each = n_time),
time = rep(0:(n_time-1), n_id),
eps_real = rnorm(n_id*n_time, mean = 0, sd = 0.5),
y = a_real + b_real * time + eps_real
)
# make sure that data format is okay
d <- d %>%
mutate(id = as_factor(id))
# something like this could work.
d %>%
ggplot(aes(x = time, y = y, color = id)) +
geom_point() +
geom_smooth(method = "lm")
fit_mod <- function(formula,
family,
data,
prior,
sample_prior,
file){
b <- brm(
formula = formula,
family = family,
data = data,
prior = prior,
cores = 4, chains = 2,
sample_prior = sample_prior,
backend = "cmdstanr",
file = file,
file_refit = "on_change",
threads = threading(2),
control = list(adapt_delta = .99,
max_treedepth = 20)
)
return(b)
}
# fit a model
f0 <- bf(y ~ time) # no random effects structure.
f1 <- bf(y ~ time + (1|id)) # random intercept.
f2 <- bf(y ~ time + (1+time|id)) # random intercept & slope.
#ff3 <- bf(y ~ time + I(time^2) + (1+time|id)) # time second order
# fit the first model
get_prior(formula = f0,
data = d,
family = gaussian,
)
# set priors: here we only have sigma - not SD.
prior_f0 <- c(
prior(normal(0, .3), class = b),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sigma)
)
# fit the prior
m0_prior <- fit_mod(
formula = f0,
family = gaussian,
data = d,
prior = prior_f0,
sample_prior = "only",
file = "../models/f0_prior"
)
# fit the posterior
m0_post <- fit_mod(
formula = f0,
family = gaussian,
data = d,
prior = prior_f0,
sample_prior = T,
file = "../models/f0_post"
)
# try the model with only intercepts
get_prior(formula = f1,
data = d,
family = gaussian)
# specify prior
prior_f1 <- c(
prior(normal(0, .3), class = b),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sd),
prior(normal(0, .5), class = sigma)
)
# fit prior model
m1_prior <- fit_mod(
formula = f1,
family = gaussian,
data = d,
prior = prior_f1,
sample_prior = "only",
file = "../models/m1_prior"
)
# fit model (go back to prior pred).
m1_post <- fit_mod(
formula = f1,
family = gaussian,
data = d,
prior = prior_f1,
sample_prior = T,
file = "../models/m1_post"
)
# prediction within groups (how will they continue to develop).
get_prior(formula = f2,
data = d,
family = gaussian)
# set priors
prior_f2 <- c(
prior(normal(0, .3), class = b),
prior(lkj(2), class = cor),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sd),
prior(normal(0, .5), class = sigma)
)
# fit prior model
m2_prior <- fit_mod(
formula = f2,
family = gaussian,
data = d,
prior = prior_f2,
sample_prior = "only",
file = "../models/m2_prior")
# fit the posterior
m2_post <- fit_mod(
formula = f2,
family = gaussian,
data = d,
prior = prior_f2,
sample_prior = T,
file = "../models/m2_post"
)
## pp checks
## models
## loo
## pp checks
pp_check(m0_prior)
## pp checks
pp_check(m0_prior, nsamples = 50)
pp_check(m1_prior, nsamples = 50)
pp_check(m2_prior, nsamples = 50)
#### posteriors
pp_check(m0_post, nsamples = 50)
pp_check(m1_post, nsamples = 50)
pp_check(m2_post, nsamples = 50)
?add_criterion
## loo
m0_post <- add_criterion(m0_post, criterion = c("loo", "bayes_R2"))
m1_post <- add_criterion(m1_post, criterion = c("loo", "bayes_R2"))
m2_post <- add_criterion(m2_post, criterion = c("loo", "bayes_R2"))
loo_compare(m0_post, m1_post, m2_post)
loo_model_weights(m0_post, m1_post, m2_post)
# student-t
f3 <- bf(y ~ time + (1+time|id)) # random intercept & slope.
# check data
get_prior(formula = f3,
data = d,
family = student)
# set priors
prior_m3 <- c(
prior(normal(0, .3), class = b),
prior(lkj(2), class = cor),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sd),
prior(normal(0, .5), class = sigma),
prior(gamma(2, 0.1), class = nu)
)
# set priors
prior_f3 <- c(
prior(normal(0, .3), class = b),
prior(lkj(2), class = cor),
prior(normal(1, .5), class = Intercept),
prior(normal(0, .5), class = sd),
prior(normal(0, .5), class = sigma),
prior(gamma(2, 0.1), class = nu)
)
# fit prior model
m3_prior <- fit_mod(
formula = f3,
family = student,
data = d,
prior = prior_f3,
sample_prior = "only",
file = "../models/m3_prior")
# fit the posterior
m3_post <- fit_mod(
formula = f3,
family = student,
data = d,
prior = prior_f3,
sample_prior = T,
file = "../models/m3_post"
)
# pp
pp_check(m3_prior, nsamples = 50)
pp_check(m3_post, nsamples = 50)
## loo
m3_post <- add_criterion(m3_post, criterion = c("loo", "bayes-R2"))
## loo
m3_post <- add_criterion(m3_post, criterion = c("loo", "bayes_R2"))
loo_compare(m2_post, m3_post)
loo_model_weights(m2_post, m3_post)
m2_post
#
m0_post
m1_post
m3_post
m3_post
# write csv.
write_csv(d, "data.csv")
# write csv.
write_csv(d, "../data/data.csv")
View(d)
